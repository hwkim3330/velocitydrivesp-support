#!/usr/bin/env ruby

# Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
# SPDX-License-Identifier: MIT

require 'rubygems'
require 'bundler/setup'

require 'pp'
require 'yaml'
require 'json'
require 'open3'
require 'base64'
require 'logger'
require 'nokogiri'
require 'optparse'
require 'fileutils'
require 'asciidoctor'
require 'asciidoctor/extensions'
require 'json_schemer'
require_relative './parse.rb'
require_relative './parse-yang.rb'
require 'digest'

# TODO:
# - Ensure linking to stand-alone adoc sections works
# - Enforce relation type
# - Facilitate referencing external documents

$opt = {
  :sitemap => "docs/sitemap.yaml",
  :output => "velocitysp-doc.html",
}

global = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0}"

    opts.on("-r", "--revision [REV]", "Revision") do |r|
        $opt[:rev] = r
    end

    opts.on("-w", "--write-sym", "Write YANG symbol tables to file") do
        $opt[:write_sym] = true
    end

    opts.on("-y", "--ysym", "Dump YANG symbol table") do
        $opt[:ysym] = true
    end

    opts.on("-m", "--sitemap <FILE>", "Sitemap file to use") do |f|
        $opt[:sitemap] = f
    end

    opts.on("-o", "--output <FILE>", "Output file") do |f|
        $opt[:output] = f
    end

end.order!

$log = Logger.new(STDOUT)
$log.level = Logger::INFO

$fbasename = File.basename(__FILE__)   # get base filename with extension

$log_errors = 0
def log_error(m)
  $log.error m
  $log_errors += 1
end

def log_global line, level, msg
  m = "#{$fbasename}:#{line} #{msg}"
  case level
  when :error
    log_error m
  when :warn
    $log.warn m
  when :info
    $log.info m
  when :debug
    $log.debug m
  else
    raise "unexpected level"
  end
end

$top = File.expand_path(__FILE__)
3.times do
    $top = File.dirname($top)
end

Dir.chdir($top)

if not $opt[:rev]
  begin
    $opt[:rev] = YAML.load_file("#{$top}/.version.yaml")["lm_version"]
  rescue => e
    $opt[:rev] = "VelocitySP (unknown version)"
    #puts e.backtrace.join("\n\t")
    #  .sub("\n\t", ": #{e}#{e.class ? " (#{e.class})" : ''}\n\t")
  end
end

$doc_top = "#{$top}/docs/"
$html_out = "#{$doc_top}/html"
system "rm -rf #{$html_out}"
system "mkdir #{$html_out}"
system "cp -r support/dg/resources/* #{$html_out}/."
system "./support/scripts/dgyamlcombine -o local-test-results.yaml"

class TestResults
    def initialize
        @populated = false
        @test_results = {}
    end

    def test_res_add tc, rec
        arr = @test_results[tc]
        if arr.nil?
            arr = []
            @test_results[tc] = arr
        end
        arr << rec
    end

    def populate sm, data
      return if data.nil?

      data.each do |res|
        tc = res["testcase"]
        res["testcase"] = sm.symbol_link("a", tc, tc, true)
        if sm.symbol_exist("a", tc)
            res["testcase"] += " (test-case-present)"
        else
            res["testcase"] += " (test-case-missing)"
        end

        test_res_add tc, res
      end
    end

    def cross_ref sm
        @test_results.each do |k, v|
            v.each do |r|
                r["testcase"] = sm.symbol_link("a", k)
            end
        end
    end

    def get_test_db sm
        db = []
        @test_results.each do |k, v|
            v.each do |r|
                db << r
            end
        end

        return db
    end

    def test_result_string sm, tc

        results = @test_results[tc]
        if results.nil? or results.size == 0
            return "No results available"
        end

        hist = results.collect{|x| x["testresult"]}.tally.to_a
        s = "#{results.size} results, #{hist.collect{|x| "#{x[0]}: #{x[1]}"}.join(", ")}"
        return "<a href=\"#docs/sw_test/test_results.html|testcase=^#{tc}$\">#{s}</a>"
    end
end

class Sitemap
  attr_reader :conf
  def initialize sitemap
    @conf = YAML::load(File.open(sitemap))
    @page_id = 0
    @pages = {}
    @anchor = {} # hash of arrays. Key is the anchor, and the array list the files matching
    @@sym_db = {}
    @@data_in = {}
    @schema_validator = {}
    @test_results = TestResults.new

    # load inputs
    @conf["data_input"].each do |e|
      begin
        @@data_in[e["name"]] = File.open(e["path"]) { |f| Nokogiri::XML(f) }
        $log.info "#{$fbasename}:#{__LINE__} Loaded data_input: #{e["path"]}"
      rescue
        $log.info "#{$fbasename}:#{__LINE__} Skipping data_input: #{e["path"]}"
      end
    end

    # load the MCHP LADF JSON schema
    begin
      @@data_in[@conf["mchp_ladf"]["name"]] = File.read(@conf["mchp_ladf"]["path"]) { |f| f.to_s }

      $log.info "#{$fbasename}:#{__LINE__} Loading MCHP Lifecycle Artifact Data Format Schema: #{@conf["mchp_ladf"]["path"]}"

      @schema_validator = JSONSchemer.schema(@@data_in[@conf["mchp_ladf"]["name"]])
      $log.info "#{$fbasename}:#{__LINE__} Loaded schema: #{@schema_validator}"
    rescue => err
      $log.warn "Exception caught during schema read: #{err.to_s}"
      $log.warn "#{$fbasename}:#{__LINE__} Skipping Data Format Schema: #{@conf["mchp_ladf"]["path"]}}"
    end

  end

  def add_anchor anchor, file
        # autogenerated anchors are prefixed with "_", do not expect that they
        # are global uniq
      if @anchor[anchor].nil?
          @anchor[anchor] = [file]
      else
          @anchor[anchor] << file
          if not anchor =~ /^_.*/
              $log.warn "#{$fbasename}:#{__LINE__} Anchor #{anchor} defined multiple places: [#{@anchor[anchor].join(", ")}]"
          end
      end
  end

  def resolve_link_to_file_anc src_file, hash
      # Remove query portion
      anc_or_file = hash.sub(/\|.*/, "")

      if @pages[anc_or_file]
          return hash, nil
      end

      files = @anchor[anc_or_file]
      if files.nil?
          $log.warn "#{$fbasename}:#{__LINE__} Dead link in #{src_file}, anchor-and-or-file: #{anc_or_file}"
          return nil, nil
      end

      if anc_or_file =~ /^_.*/
          # Local link - allow more matches
          if not files.include? src_file
              $log.warn "#{$fbasename}:#{__LINE__} Dead local-link in #{src_file}, anchor-and-or-file: #{anc_or_file}"
          end
          return src_file, hash
      end

      if files.size > 1
          $log.warn "#{$fbasename}:#{__LINE__} Ambiguity link #{anc_or_file} in #{src_file}"
      end

      return files[0], hash
  end

  def data_arr_xpath q
      val = []
      @@data_in.each do |k, v|
          begin
              val += v.xpath(q)
          rescue
          end
      end
      return val
  end

  def test_result_string tc
      @test_results.test_result_string self, tc
  end

  def data_in_xpath q
    val = []
    @@data_in.each do |k, v|
      begin
        val += v.xpath(q).collect{|x| x.value}
      rescue
      end
    end

    if val.size != 1
      return nil
    else
      return val.first
    end
  end

  def get_test_db
      return @test_results.get_test_db(self)
  end

  def symbol_ns ns
    if @@sym_db[ns].nil?
      @@sym_db[ns] = {}
    end
    return @@sym_db[ns]
  end

  def symbol_id ns, id
    idx = symbol_ns(ns)
    if idx[id].nil?
      idx[id] = { "use" => {} }
      $log.debug "#{$fbasename}:#{__LINE__} Added #{id} to index of namespace \"#{ns}\""
    else
      $log.debug "#{$fbasename}:#{__LINE__} Located #{id} in index of namespace \"#{ns}\" with content:\n #{idx[id]}"
    end
    return idx[id]
  end

  def symbol_decl ns, id, type, page_path
    id_ = symbol_id ns, id

    if id_["link"]
      log_error "#{$fbasename}:#{__LINE__} Symbol #{ns}/#{id} already defined in #{id_["link"]}"
      return
    else
      id_["link"] = "##{page_path}@#{id}"
      id_["type"] = type

      $log.debug "#{$fbasename}:#{__LINE__} Added \"#{id}\" with link path \"#{id_["link"]}\" to symbol database"
    end

    return "<a id=#{id} href=#{id_["link"]}>#{id}</a>"
  end

  def symbol_use ns, decl_id, use_id, type, page_path
    $log.debug "#{$fbasename}:#{__LINE__} Symbol: #{decl_id} referenced by #{use_id}"
    id_ = symbol_id ns, use_id

    if id_["use"][decl_id]
      log_error "#{$fbasename}:#{__LINE__} Symbol #{ns}/#{use_id}, already declared used by #{decl_id}"
    else
      e = {"link" => "##{dir}/#{base}@#{decl_id}", "type" => type}
      id_["use"][decl_id] = e
    end
  end

  def symbol_exist ns, id
    idx = @@sym_db[ns]

    if idx.nil?
        return false
    end

    if idx[id].nil?
        return false
    end

    return true
  end

  def symbol_link ns, id, display = nil, ignore_error = false
    display = id if display.nil?
    idx = @@sym_db[ns]

    if idx.nil?
      if not ignore_error
        log_error "#{$fbasename}:#{__LINE__} Link to ID: #{ns}/#{id} could not be resolved: No namespace for #{ns}"
      end
      return id
    end

    if idx[id].nil?
      if not ignore_error
        log_error "#{$fbasename}:#{__LINE__} Link to ID: #{ns}/#{id} could not be resolved: No entry in namespace for #{id}"
      end
      return id
    end

    return "<a href=#{idx[id]["link"]}>#{display}</a>"
  end

  def symbol_link_c id, display = nil
    display = id if display.nil?
    sym = $symbol_index[id]

    if sym.nil?
      log_error "dg.rb:#{__LINE__} Link to C-symbol: #{id} could not be resolved"
      return id
    else
      return "<a href=\"#symd:#{id}\">#{display}</a>"
    end
  end

  def symbol_link_self ns, id
    idx = @@sym_db[ns]
    if idx.nil?
      log_error "#{$fbasename}:#{__LINE__} Link to ID: #{ns}/#{id} could not be resolved"
      return id
    end

    if idx[id].nil?
      log_error "#{$fbasename}:#{__LINE__} Link to ID: #{ns}/#{id} could not be resolved"
      return id
    else
      return "<a id=\"#{id}\" href=\"#{idx[id]["link"]}\">#{id}</a>"
    end
  end

  def link_file file, display = nil
      display = file if display.nil?
      match = []
      base = File.basename(file)
      @pages.each do |path, obj|
          if base == File.basename(obj.src_file)
              match << obj
          end
      end

      if match.size != 1
        match = []
        @pages.each do |path, obj|
          if file == obj.src_file
            match << obj
          end
        end
      end

      if match.size == 1
          return "<a href=\"##{match[0].html_file_name}\">#{display}</a>"
      else
          log_error "#{$fbasename}:#{__LINE__} Match cnt != 1 searching for #{file} in sitemap"
          return file
      end
  end


  def populate_src src_file, id
    return nil if src_file.nil?

    content = IO.binread(src_file)

    $log.info "#{$fbasename}:#{__LINE__} Processing #{src_file}"
    page = nil
    case File.extname(src_file)
    when ".adoc"
      page = PageAdoc.new self, src_file, content, @schema_validator
    when ".h", ".c"
      page = PageC.new self, src_file, content
    when ".yang"
      page = PageYang.new self, src_file, content
    when ".tree"
      page = PageYangTree.new self, src_file, content
    when ".html"
      page = PageHtml.new self, src_file, content
    else
      page = PageTxt.new self, src_file, content
    end

    page.populate
    @pages[page.html_file_name] = page

    $log.debug "#{$fbasename}:#{__LINE__} DONE Processing #{src_file}"

    return {
      :name      => page.name,
      :html_path => page.html_file_name,
      :id        => id,
      :icon      => page.icon,
    }
  end

  def populate_ conf_pages
    return nil if conf_pages.nil?

    res = []

    conf_pages.each do |p|
        @page_id += 1
        id = @page_id
        page_entry = {
            :name  => p["name"],
            :src   => populate_src(p["src"], id),
            :pages => populate_(p["pages"]),
            :id    => id
        }

        page_entry[:name] = page_entry[:src][:name] if page_entry[:name].nil?
        res << page_entry
    end

    return res
  end

  def populate_yaml_input y
    return if y.nil?

    y.each do |i|
      data = nil
      if i["path"]
        begin
          data = YAML::load_file(i["path"])
        rescue
          log_error "#{$fbasename}:#{__LINE__} Failed to load yaml input from file: #{i["path"]}"
        end
      end

      #TODO, check against schema

      # For now, only allow loading test-results in this way (as other
      # objects will not be shown)
      @test_results.populate(self, data["test-results"])
    end
  end

  def populate
    @js_page_map = populate_ @conf["pages"]

    # load yaml/objects not inlined in adoc
    populate_yaml_input(@conf["sdlc_objects"])
  end

  def cross_ref
    @pages.each do |path, obj|
      $log.debug "Cross reference: #{path}"
      obj.cross_ref
    end
    @test_results.cross_ref(self)
  end

  def href_page page, anc = nil
    l = "href=\"##{page}\""
    if anc
      l += "@#{anc}"
    end

    return l
  end

  def inline_js path
    buf = "<script type=\"text/javascript\">\n".b
    buf += IO.binread(path)
    buf += "\n</script>\n".b
    return buf
  end

  def inline_css path
    buf = "<style>\n".b
    buf += IO.binread(path)
    buf += "\n</style>\n".b
    return buf
  end

  def gen_menu_list list, indent = "", id_ = nil
    id_ = " id=\"#{id_}\"" if id_
    s = "#{indent}<ul#{id_}>\n"
    list.each do |e|
      s += gen_menu_element(e, "#{indent}  ")
    end
    s += "#{indent}</ul>\n"
  end

  def gen_menu_element page, indent = ""
    s  = "#{indent}<li id=\"li#{page[:id]}\">\n"
    if page[:src] and page[:src][:html_path]
      if page[:src][:icon]
        ii = "#{indent}  <i class=\"stm-icon #{page[:src][:icon]} fa-sm\"></i>\n"
      else
        ii = "#{indent}  <i class=\"stm-icon far fa-file fa-sm\"></i>\n"
      end
      i  = "<span class=\"stm-icon\">#{ii}</span>"
      s += "#{indent}  <a class=\"stm-content\" #{href_page(page[:src][:html_path])}>#{i}#{page[:name]}</a>\n"
    else
      ii = "#{indent}  <i class=\"stm-icon far fa-folder fa-sm\"></i>\n"
      i  = "<span class=\"stm-icon\">#{ii}</span>"
      s += "#{indent}  <span class=\"stm-content\">#{i}#{page[:name]}</span>\n"
    end
    s += gen_menu_list(page[:pages], "#{indent}  ") if page[:pages]
    s += "#{indent}</li>\n"
  end

  def html
    js_default_page = nil # path of default page to load
    js_pages = {}

    @pages.each do |path, p|
      js_default_page = path if js_default_page.nil? # set default page to first page
      js_pages[path] = p.html

      File.write("#{$html_out}/#{path.gsub("/", "_")}.html", js_pages[path])
    end

    html = "".b
    html += "<html lang=\"en\">\n".b
    html += "<head>\n".b
    html += "  <meta charset=\"UTF-8\">\n".b
    html += "  <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' data: 'unsafe-inline' \">".b
    html += "  <title>VelocitySP Doc</title>\n".b

    # TODO, we should create a style-sheet that is inhireted by the scss asciidoctor
    # component, and based on foundation. This should replace all of this
    html += inline_css "./support/dg/resources/bootstrap-4.6.2.min.css"
    html += inline_css "./support/dg/resources/jquery-simpleTreeMenu.css"
    html += inline_css "./support/dg/resources/asciidoctor-default.css"
    html += inline_css "./support/dg/resources/mesa.css"
    html += inline_css "./support/dg/resources/jsgrid/dist/jsgrid.min.css"
    html += inline_css "./support/dg/resources/jsgrid/dist/jsgrid-theme.min.css"

    html += "  <script type=\"text/javascript\">\n"
    html += "      FontAwesomeConfig = {\n"
    html += "          autoReplaceSvg: true,\n"
    html += "          observeMutations: true,\n"
    html += "      }\n"
    html += "  </script>\n"

    html += inline_js("./support/dg/resources/jquery-3.7.1.min.js")
    html += inline_js("./support/dg/resources/jsgrid/dist/jsgrid.min.js")
    html += inline_js("./support/dg/resources/jquery-simpleTreeMenu.js")
    html += inline_js("./support/dg/resources/fontawesome-free-5.10.1-web/js/solid.min.js")
    html += inline_js("./support/dg/resources/fontawesome-free-5.10.1-web/js/regular.min.js")
    html += inline_js("./support/dg/resources/fontawesome-free-5.10.1-web/js/fontawesome.min.js")
    html += "  <script type=\"text/javascript\">\n".b
    html += "  var default_page = #{js_default_page.to_json};\n".b
    html += "  var pages = #{js_pages.to_json};\n".b
    html += "  var c_symbol = #{JSON.pretty_generate($symbol_index)};\n".b
    html += "  var y_symbol = #{JSON.pretty_generate($yang_symbol_index)};\n".b
    html += "  var test_results = #{JSON.pretty_generate(get_test_db())};\n".b
    html += "  </script>\n".b
    html += inline_js("./support/dg/resources/velocitysp-doc.js")

    html += "</head>\n"
    html += "<body>\n"
    html += "  <div class=\"container\">\n"
    html += "    <div class=\"row\">\n"
    html += "      <div class=\"col-lg-12\">\n"
    html += "        <h1>#{$opt[:rev]}</h1>\n"
    html += "      </div>\n"
    html += "    </div>\n"
    html += "    <div class=\"row\">\n"
    html += "      <div class=\"col-lg-3\">\n"
    html += "        <div style=\"background-color: white\" class=\"well\">\n"
    html += gen_menu_list(@js_page_map, "          ", "demoTree")
    html += "        </div>\n"
    html += "      </div>\n"
    html += "      <div class=\"col-lg-9\">\n"
    html += "        <div style=\"background-color: white\" class=\"well\" id=\"content\">\n"
    html += "        </div>\n"
    html += "      </div>\n"
    html += "    </div>\n"
    html += "  </div>\n"
    html += "</body>\n"
    html += "<script type=\"text/javascript\">\n"
    html += "hashChange(null);\n"
    html += "$('#demoTree').simpleTreeMenu();\n"
    html += "</script>\n"
    html += "</html>\n"

    #Nokogiri::HTML(html).to_xhtml(indent: 2)
    html
  end
end

class Page
  attr_reader :icon, :content, :dir, :id, :images, :name, :src_file, :base
  def initialize sm, src_file, content
    @sitemap = sm
    @src_file = src_file
    @dir = File.dirname(@src_file)
    @ext = File.extname(@src_file)
    @base = File.basename(@src_file, @ext)
    @content = content
  end

  def log line, level, msg
    log_global line, level, "#{@base}#{@ext}, #{msg}"
  end

  def html_file_name
    @src_file
  end

  def name
    "#{@base}#{@ext}"
  end

  def data_in_xpath q
    return @sitemap.data_in_xpath q
  end

  def test_result_string tc
      @sitemap.test_result_string tc
  end

  def value_adoc_to_html value, id = nil
    logger = Asciidoctor::MemoryLogger.new
    Asciidoctor::LoggerManager.logger = logger

    doc = Asciidoctor::Document.new(value, {
      :header_footer => false,
      :safe => Asciidoctor::SafeMode::UNSAFE,
      :attributes => {
        "backend" => "xhtml5",
        "sectnums" => true,
        "sectnumlevels" => "5",
        "sectanchors" => true,
        "sectlinks" => true,
        "outfilesuffix" => "/",
        #"source-highlighter" => "pygments",
        #"pygments-linenums-mode" => "inline",
        "icons" => "font",
      }
    })

    xml = Nokogiri::HTML::DocumentFragment.parse(doc.render)
    logger.messages.each do |m|
      log_error "Processing ADOC snippet in #{@src_file} (#{id}), msg: #{m[:message][:text]}"
      log_error value
      log_error ""
    end

    update_code_refs(xml)
    xml.to_html
  end

end

# Preprocess all .adoc files and replace [plantuml] with [source, plantuml].
# Asciidoctor.js Live Preview requires [plantuml] and the dg script requires
# [source, plantuml].
class PlantUmlPreprocessor < Asciidoctor::Extensions::Preprocessor
  def process document, reader
    newlines = []
    oldlines = reader.read_lines
    while !oldlines.empty?
      line = oldlines.shift
      if line.include?("[plantuml]")
        newlines << "[source, plantuml]"
      else
        newlines << line
      end
    end
    reader.restore_lines newlines
    reader
  end
end

Asciidoctor::Extensions.register do
  preprocessor PlantUmlPreprocessor
end

class PageAdoc < Page
  @@obj_db = {}
  def initialize sm, src_file, content, sch_validator
    super sm, src_file, content
    @spec = sm.conf["yaml_blocks"]
    @blocks = {}
    @schema_validator = sch_validator
  end

  def icon
    "far fa-file-alt"
  end

  def name
    @base
  end

  def adoc_block_type_defined? type
    return @spec[type]
  end

  def adoc_id_to_obj id
    #log __LINE__, :info, "Lookup: #{id}"
    return @@obj_db[id]
  end

  def adoc_symbol_decl id, type, obj = nil
    begin
      @sitemap.symbol_decl "a", id, type, html_file_name()
      if obj
        @@obj_db[id] = obj
        log __LINE__, :debug, "Declaring \"#{id}\" with object"
      else
        log __LINE__, :debug, "Declaring \"#{id}\" without object"
      end
    rescue
      log __LINE__, :error, "Exception during processing of id: #{id}, type: #{type} in file: #{html_file_name()}"
      return
    end

  end

  def symbol_link_c id, display = nil
    return @sitemap.symbol_link_c id, display
  end

  def link_file id, display = nil
    return @sitemap.link_file id, display
  end

  def adoc_symbol_link id, display = nil
    return @sitemap.symbol_link "a", id
  end

  def adoc_symbol_link_self id
    return @sitemap.symbol_link_self "a", id
  end

  def adoc_symbol_use ns, decl_id, use_id, type, page_path
    return @sitemap.symbol_use "a", decl_id, use_id, type, page_path
  end

  def validate_yml yaml_doc
    # Validate the all YAML in this ADOC page for MCHP LADF compliance
    begin
      # Convert YAML input to JSON for validation
      json_document = JSON.parse(yaml_doc.to_json)

      # Validate and feedback each error as nice as possible
      yaml_errors = 0
      @schema_validator.validate(json_document).each do |error|
        yaml_errors += 1
        $log.info  JSONSchemer::Errors.pretty(error)
      end

      if yaml_errors > 0
        $log.debug yaml_doc.to_yaml
        log_error "#{yaml_errors} Error(s) in YAML detected above"
        raise "YAML is not MCHP SW DOC LADF compliant!"
      else
        $log.debug "YAML is MCHP SW DOC LADF compliant - Excellent!"
      end

    rescue => e
      log_error "Exception caught:"
      log_error e.to_s
      log_error "YAML input to block throwing exception: \n#{yaml_doc.to_s}"
      raise e
    end
  end

  def plantuml_to_svg_cache path
    return nil if not File.exist? path
    svg = File.read(path)
    return nil if svg.size == 0
    return svg
  end

  def plantuml_compile plantuml
    Open3.popen3('plantuml -tsvg -pipe') do |i, o, e, t|
      i.write(plantuml)
      i.close

      os = nil
      es = nil

      to = Thread.new do
        os = o.read
      end

      te = Thread.new do
        es = e.read
      end
      to.join
      te.join
      code = t.value

      if es.size == 0 and code.to_i == 0
        return os
      else
        log_error "#{$fbasename}:#{__LINE__} Error running plantuml\nreturn-code: #{code.to_i}\nstderr:\n#{es}\n"
        log_error "#{$fbasename}:#{__LINE__}\n\nInput:\n#{plantuml}\n\n"
        return nil
      end
    end
  end

  def plantuml_to_img plantuml
    mime = nil
    md5 = Digest::MD5.hexdigest(plantuml).to_s
    cache_file = ".plantuml-cache/#{md5}"

    svg = plantuml_to_svg_cache cache_file
    if svg
      $log.info "#{$fbasename}:#{__LINE__}   plantuml cache-hit: #{@dir}/#{@base}#{@ext} MD5: #{md5}"
    else
      svg = plantuml_compile plantuml
      File.write(cache_file, svg) if svg
      $log.info "#{$fbasename}:#{__LINE__}   plantuml cache-miss: #{@dir}/#{@base}#{@ext} MD5: #{md5}"
    end

    if svg
      mime = %x{file --mime-type -b #{cache_file}}.strip
    end

    return svg, mime
  end

  def populate
    $log.debug "#{$fbasename}:#{__LINE__} Asciidoctor Cross-index-processing: #{@dir}/#{@base}#{@ext}"
    doc = Asciidoctor::Document.new(content, {
        :header_footer => false,
        :safe => Asciidoctor::SafeMode::UNSAFE,
        :attributes => {
            "backend" => "xhtml5",
            "sectnums" => true,
            "sectnumlevels" => "5",
            "sectanchors" => true,
            "sectlinks" => true,
            "outfilesuffix" => "/",
            #"source-highlighter" => "pygments",
            #"pygments-linenums-mode" => "inline",
            "icons" => "font",
        }
    })

    @xml = Nokogiri::HTML::DocumentFragment.parse(doc.render)

    # Register all YAML blocks in @blocks using a md5 sum. Still do not replace.
    yaml_document = ""
    @xml.css(".language-yaml").each do |e|
      begin
        md5 = Digest::MD5.hexdigest(e.inner_text)
        yaml = YAML::load(e.inner_text)

        validate_yml(yaml)

        if yaml.nil? or yaml == false
          $log.info "#{$fbasename}:#{__LINE__} Skipping empty section!"
          next
        end

        if not yaml.is_a?(Hash)
          $log.warn "#{$fbasename}:#{__LINE__} Yaml snippet is not a MAP"
          next
        end

        yaml.each do |type, v|
          $log.debug "#{$fbasename}:#{__LINE__} Detected YAML of type: #{type.to_s}"
          spec = @spec[type]

          if not v.is_a?(Array)
            if v
              # Lets allow an empty object as a place holder
              $log.warn "#{$fbasename}:#{__LINE__} Yaml MAP Value is not an array"
            end
            next
          end

          if spec
            ab = AdocBlock.new self, spec, type, v
            ab.populate
            @blocks[md5] = ab
          else
            $log.warn "#{$fbasename}:#{__LINE__} Unknown yaml content type #{yaml["type"]} in #{@dir}/#{@base}#{@ext}"
          end
        end
      rescue => err
        log_error "Error procssing block:"
        log_error e.inner_text.inspect
        log_error e.inner_text

        raise err
      end
    end

   

    # Find all images and replace with inline version
    @xml.css("img[src]").each do |e|
      p = "#{dir}/#{e["src"]}"

      begin
        data = nil

        case File.extname(p)
        when ".svg"
          svg = Nokogiri::XML(File.open(p))
          data = "data:image/svg+xml;base64,#{Base64.encode64(svg.root().to_xml())}"
        when ".png"
          data = "data:image/png;base64,#{Base64.encode64(IO.binread(p))}"
        when ".jpg", ".jpeg"
          data = "data:image/jpeg;base64,#{Base64.encode64(IO.binread(p))}"
        else
          raise "Image type #{File.extname(p)} not supported (#{p})"
        end

        e.remove_attribute("src")
        e["src"] = data
      rescue
        log_error "#{$fbasename}: #{__LINE__} Failed to inline #{p}"
      end
    end

    begin
      if not File.directory? ".plantuml-cache"
        %x{mkdir -p .plantuml-cache}
      end

      lockfile = ".plantuml-cache/lock"
      lock = File.open(lockfile, File::CREAT)
      lock.flock(File::LOCK_EX)

      @xml.css(".language-plantuml").each do |element|
        img_data, mime = plantuml_to_img element.inner_text
        if img_data
          org = element.parent.parent.parent
          ids = ""
          ids = "id=\"#{org["id"]}\" " if org["id"]

          title = ""
          org.css(".title").each do |t|
            title = "<div class=\"title\">#{t.inner_text}</div>"
          end

          html = "<div #{ids}class=\"imageblock\" align=\"center\">"
          html += "<div class=\"content\">"
          html += "<img src=\"data:#{mime};base64,#{Base64.encode64(img_data)}\">"
          html += "</div>"
          html += title
          html += "</div>"

          id = org["id"]

          #puts element.parent.parent.parent
          element.parent.parent.parent.replace(html)
        end
      end
    rescue => err
      log_error "Exception caught:"
      log_error err.to_s
      log_error "#{$fbasename}:#{__LINE__} Failed to run plantuml"
    ensure
      lock.close()
    end

    # Capture all anchors to do cross-page link checkking later
    @xml.css("a").each do |e|
        next if e["href"].nil?
        next if e["href"].size == 0 or e["href"][0] != "#"

        case e["class"]
        when "anchor"
            @sitemap.add_anchor e["href"][1..], src_file
        end
    end

    # Find all icons and replace with font based icons
    @xml.css(".admonitionblock td.icon [class^=\"fa icon-\"]").each do |e|
      begin
        case e["class"]
        when "fa icon-important"
          i = "fas fa-exclamation-circle"
          c = "#bf0000"
        when "fa icon-warning"
          i = "fas fa-exclamation-triangle"
          c = "#bf6900"
        when "fa icon-caution"
          i = "fas fa-fire"
          c = "#bf3400"
        when "fa icon-note"
          i = "fas fa-info-circle"
          c = "#19407c"
        when "fa icon-tip"
          i = "far fa-lightbulb"
          c = "color:#111"
        else
          raise "No match for #{e["class"]}"
        end

        e["class"] = "#{i} fa-2x"
      rescue
        log_error "#{$fbasename}:#{__LINE__} Failed to update icon #{e}"
      end
    end

  end

  def update_code_refs xml
    # Expand code-snippets
    # We use the `code` (back-tick text back-tick) to reference code, and it is
    # useful to have an easy way of turning this into links.
    # This overloads the syntax in the following way:
    # `asdf` -> normal monospace
    # `c:some_c_symbol` this shall become a link to some_c_symbol.
    # `y:some-yang-element` this shall become a link to some-yang-element
    # `a:some-id-inlined-in-adoc`: this shall become a link to some-id-inlined-in-adoc
    # `r:a:123`: this shall be displayed as normal monospace without the "r:",
    # the result will be "a:123"

    xml.css("code").each do |e|
        if e.inner_text =~ /^r:(.*)$/
            e.replace("<code>#{$1}</code>")

        elsif e.inner_text =~ /^([a-z]):([^\[]+)(?:\[([^\]]+)\])?$/
            type = $1
            text = $2
            display = $3
            display = text if display.nil?

            case type
            when "a"
              e.replace("<code>#{adoc_symbol_link(text, display)}</code>")
            when "c"
              e.replace("<code>#{symbol_link_c(text, display)}</code>")
            when "y"
              e.replace("<code>#{parse_yang_path(@src_file, text)}</code>")
            when "f"
              e.replace("<code>#{link_file(text, display)}</code>")
            end
        end
    end

    @xml.css("a").each do |e|
        next if e["href"].nil?
        next if e["href"].size == 0 or e["href"][0] != "#"
        next if e["href"] =~ /^#(symd|sym|ysym|ysymd):/

        anc = nil
        file = nil
        anc_or_file = e["href"][1..]
        if anc_or_file =~ /([^@]+)@(.+)/
            anc = $2
            file = $1
        else
            file, anc = @sitemap.resolve_link_to_file_anc src_file, anc_or_file
        end

        if file
            if anc
                e["href"] = "##{file}@#{anc}"
            else
                e["href"] = "##{file}"
            end
        end
    end

  end

  def cross_ref
    @blocks.each do |md5, block|
      block.cross_ref
    end

    update_code_refs @xml

  end

  def html
    @xml.css(".language-yaml").each do |e|
      md5 = Digest::MD5.hexdigest(e.inner_text)
      adocblock = @blocks[md5]

      if adocblock
        replacement = adocblock.html
        e.parent.parent.parent.replace(replacement)
      end
    end

    @xml.to_html
  end
end

class PageC < Page
  def initialize sm, src_file, content
    super sm, src_file, content
  end

  def icon
    "far fa-file-code"
  end

  def populate
    old_size = $symbol_index.size
    record_symbols(get_symbol_sequence(src_file))
    log __LINE__, :debug, "Parsed: #{src_file} #{$symbol_index.size - old_size} c symbols added"
  end

  def cross_ref
  end

  def html
    seq_to_html(get_symbol_sequence(src_file), src_file)
  end
end

class PageYang < Page
  def initialize sm, src_file, content
    super sm, src_file, content
  end

  def icon
    "far fa-file-code"
  end

  def populate
    old_size = $yang_symbol_index.size
    yang_record_symbols(@src_file, yang_get_symbol_sequence(@src_file))
    $log.debug "#{$fbasename}:#{__LINE__} Parsed: #{src_file} #{$yang_symbol_index.size - old_size} yang symbols added"
    $yang_unresolved_groups.each do |grp, dummy|
        STDERR.puts "ERROR: Grouping '#{grp}' not found!"
    end
  end

  def cross_ref
  end

  def html
    yang_seq_to_html(yang_get_symbol_sequence(@src_file), @src_file)
  end
end

class PageYangTree < Page
  def initialize sm, src_file, content
    super sm, src_file, content
  end

  def icon
    "far fa-file-code"
  end

  def populate
  end

  def cross_ref
  end

  def html
    "<pre>#{@content}</pre>"
  end
end

class PageTxt < Page
  def initialize sm, src_file, content
    super sm, src_file, content
  end

  def icon
    "far fa-file-alt"
  end

  def populate
  end

  def cross_ref
  end

  def html
    "<pre>#{@content}</pre>"
  end
end

class PageHtml < Page
  def initialize sm, src_file, content
    super sm, src_file, content
  end

  def icon
    "far fa-file-alt"
  end

  def populate
  end

  def cross_ref
  end

  def html
    @content
  end
end

class AdocBlock
  def initialize page, spec, type, list
    @spec = spec
    @fields = @spec["fields"]
    @elements = []
    @type = type
    @page = page

    throw "#{$fbasename}: #{__LINE__} Unknown yaml content type #{type}" if @spec.nil?

    list.each do |e|
      @elements << AdocBlockElement.new(self, @type, @spec, e, @page)
    end
  end

  def populate
    @elements.each do |e|
      e.populate
    end
  end

  def cross_ref
    @elements.each do |e|
      e.cross_ref
    end
  end

  def html
    html = ""
    @elements.each do |e|
      html += e.html
    end
    return html
  end

  def log line, level, msg
    @page.log line, level, msg
  end
end

def c_load_proto s
  func = nil
  sym = $symbol_index[s]
  if sym and sym[:decl]
    if sym[:decl].size != 1
      $log.warn "dg.rb:#{__LINE__} Processing id: #{s}. Unexpected number of decl != 1: #{sym[:decl].size}"
    end
    return nil if sym[:decl].size == 0

    sym_file, sym_list = sym[:decl].first

    if sym_list.size != 1
      $log.warn "dg.rb:#{__LINE__} Processing id: #{s}. Unexpected number of sym_list != 1: #{sym_list.size}"
    end
    return nil if sym_list.size == 0

    decl = sym_list.first

    if decl[:type] == "function"
      func = decl
    else
      $log.warn "dg.rb:#{__LINE__} Processing id: #{s}. Unexpected type: #{decl[:type]}"
    end
  end

  if func.nil?
    log_error "dg.rb:#{__LINE__} Processing id: #{s}. Not found"
    return nil
  end
  proto = func[:proto]
  if proto.nil?
    log_error "dg.rb:#{__LINE__} Processing id: #{s}. No prototype in declaration"
    return nil
  end

  return proto
end

def c_generate_signature p
  arg_type_l_width = 0
  arg_type_r_width = 0
  arg_name_width = 0

  p[:args].each do |a|
    arg_type_l_width = a[:typestr_l].size if a[:typestr_l].size > arg_type_l_width
    arg_type_r_width = a[:typestr_r].size if a[:typestr_r].size > arg_type_r_width
    arg_name_width = a[:name].size if a[:name].size > arg_name_width
  end

  ll = []
  l  = "#{p[:return][:typestr]} "
  l += "#{p[:name]}("
  pad1 = l.size

  first = true
  p[:args].each do |a|
    if first
      first = false
      l += "#{a[:typestr_l].ljust(arg_type_l_width)} #{a[:typestr_r].rjust(arg_type_r_width)}#{a[:name]}"
    else
      l += ","
      ll << l
      l = "".ljust(pad1)
      l += "#{a[:typestr_l].ljust(arg_type_l_width)} #{a[:typestr_r].rjust(arg_type_r_width)}#{a[:name]}"
    end
  end
  l += ");"
  ll << l
  return ll.collect!{|x| "<code style=\"white-space:pre;padding:0px 0px;\">#{x}</code>"}.join("<br>")
end

def c_generate_params page, proto, yaml
  res = {}
  idx = 0

  proto[:args].each do |a|
    val = []

    dir = nil
    dir = a[:dir] if a[:dir]
    adoc_desc = nil

    # Allow loading additional details from the yaml block, and combine it with
    # the prototype from c-header
    if yaml["params"] and a[:name]
      if yaml["params"]["#{a[:name]}-in"]
        dir = :in
        adoc_desc = yaml["params"]["#{a[:name]}-in"]
      elsif yaml["params"]["#{a[:name]}-out"]
        dir = :out
        adoc_desc = yaml["params"]["#{a[:name]}-out"]
      elsif yaml["params"]["#{a[:name]}-inout"]
        dir = :inout
        adoc_desc = yaml["params"]["#{a[:name]}-inout"]
      elsif yaml["params"]["#{a[:name]}-io"]
        dir = :inout
        adoc_desc = yaml["params"]["#{a[:name]}-io"]
      elsif yaml["params"]["#{a[:name]}"]
        adoc_desc = yaml["params"]["#{a[:name]}"]
      end
    end

    key = "<code style=\"white-space:pre;\">P#{idx}"
    if dir == :in
      key += "-IN:  "
    elsif dir == :out
      key += "-OUT: "
    elsif dir == :inout
      key += "-IO:  "
    else
      key += ":     "
    end

    if a[:name]
      key += "#{a[:name]}"
    else
      key += "<anonymous>"
    end
    key += "</code>"

    if adoc_desc
      val << adoc_desc
    else
      val << a[:desc] if a[:desc]
    end

    res[key] = page.value_adoc_to_html(val)
    idx += 1
  end

  return res
end

def c_generate_return page, proto, yaml
  val = []

  if yaml["params"] and yaml["params"]["return"]
    val << yaml["params"]["return"]
  elsif proto[:return][:desc]
    val << proto[:return][:desc]
  end

  return page.value_adoc_to_html(val)
end

class AdocBlockElement
  attr_accessor :parent, :kids
  attr_reader :id, :cross_link_records, :type, :c_proto, :yaml
  def initialize snippet, type, spec, yaml, page
    @snippet = snippet
    @type = type
    @spec = spec
    @yaml = yaml
    @fields = {}
    @page = page
    @kids = []
    @parent = nil
    @cross_link_records = {}
    @flags = @spec["flags"]
    @flags = [] if @flags.nil?

    @spec["fields"].each do |field, s|
      @fields[field] = YField.new(self, field, s, @yaml[field], @page)
    end

    @id = nil
    @id_field = nil
    @fields.each do |n, f|
      if f.type == :id
        @id = f.yaml_value
        @id_field = f
      end
    end

  end

  def log line, level, msg
    @snippet.log line, level, "ID=#{@id}, #{msg}"
  end

  def populate
    if @id
      @page.adoc_symbol_decl @id, @type, self
    end

    @fields.each do |n, f|
      f.populate()
    end
  end

  def cross_ref
    if @id and @id_field and @id_field.flags.include?(:load_defaults_from_c_hdr)
      csym = ""

      # By default derive the c symbol from the ID
      if @id =~ /([A-Za-z0-9_]+)$/
        csym = $1
      end
      @fields["c"].default_set csym

      # If 'c' was manually set, then that needs to take precendence
      csym = @fields["c"].yaml_value
      log __LINE__, :debug, "Apply defaults from C-hdr using symbol #{csym}"

      @c_proto = c_load_proto(csym)

      if @c_proto.nil?
        log __LINE__, :error, "Could not load prototype from c-headers"
      else
        @fields["description"].default_set(@c_proto[:desc])
        @fields["c_signature"].default_set(c_generate_signature(@c_proto))
        @fields["c_params"].default_set(c_generate_params(@page, @c_proto, @yaml))
        @fields["c_return"].default_set(c_generate_return(@page, @c_proto, @yaml))
      end
    end

    @fields.each do |n, f|
      f.cross_ref_parent
    end

    data_record = {}
    @fields.each do |n, f|
      data_record[n] = f.value
    end

    @fields.each do |n, f|
      f.cross_ref_id data_record
    end
  end

  def cross_link_record rel_name, record
    rel = @cross_link_records[rel_name]
    if rel.nil?
      @cross_link_records[rel_name] = []
      rel = @cross_link_records[rel_name]
    end
    #log __LINE__, :info, "Adding record to #{rel_name} int ID: #{@id}"
    rel << record
  end

  def get_field_val field
    f = @fields[field]
    if f
      return f.value
    end

    return nil
  end

  def test_result_string
      @page.test_result_string @id
  end

  def html
    return "" if @flags.include?(:nohtml)
    #$log.info "#{$fbasename}:#{__LINE__} ID: #{@id} START"
    width = 20
    html = "<table class=\"tableblock frame-all grid-all stretch\" style=\"width:100%;\"><colgroup><col style=\"width: #{width}%;\"><col style=\"width: #{100 - width}%;\"></colgroup><tbody>"

    @fields.each do |n, field|
      if field.skip?
        next
      end

      #$log.info "#{$fbasename}:#{__LINE__} ID: #{@id} Field: #{field.name}"

      #if e[field].nil?
      #  if s[:flags].include? :req
      #    log_error, "#{$fbasename}:#{__LINE__} Processing id: #{@id} required field #{field} not found"
      #    return nil
      #  elsif s[:default]
      #    data = s[:default]
      #  end
      #else
      #  data = e[field]
      #end

      value = field.html

      if value.is_a?(Hash)
        value.each do |k, v|
          html += "<tr>"
          html += "<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">#{k}</p></td>"
          html += "<td class=\"tableblock halign-left valign-top\">#{v}</td>"
          html += "</tr>"
        end
      else
        if field.flags.include? :hdr
          #$log.info "dg.rb:#{__LINE__} ID: #{@id}, Adding header: #{field.name}"
          html += "<tr>"
          html += "<th class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">#{field.name}</p></th>"
          html += "<th class=\"tableblock halign-left valign-top\">#{value}</th>"
          html += "</tr>"
        else
          #$log.info "dg.rb:#{__LINE__} ID: #{@id}, Adding field: #{field.name}"
          html += "<tr>"
          html += "<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">#{field.name}</p></td>"
          html += "<td class=\"tableblock halign-left valign-top\">#{value}</td>"
          html += "</tr>"
        end
      end
    end

    html += "</tbody></table>"
    #$log.info "#{$fbasename}:#{__LINE__} ID: #{@id} end"

    return html
  end
end

class YField
  attr_reader :yaml_value, :type, :flags

  def initialize element, yaml_name, spec, yaml_value, page
    @spec = spec
    @element = element
    @yaml_name = yaml_name
    @yaml_value = yaml_value
    @flags = @spec[:flags]
    @flags = [] if @flags.nil?
    @type = @spec[:type]
    @page = page
    @xpath_data = @spec[:xpath_data]
  end

  def check_required
    if @flags.include? :req and @yaml_value.nil?
      @element.log __LINE__, :error, "required field #{field} not found"
    end
  end

  def populate
    if @xpath_data
      xp = @xpath_data.clone

      id_content = @element.get_field_val("id")
      xp.gsub!("$id", id_content)

      yang_content = @element.get_field_val("yang")
      if yang_content
        xp.gsub!("$yang", yang_content)
      end

      res = @page.data_in_xpath xp
      if res
        @yaml_value = res
      end
    end
  end

  def skip?
    if @flags.include?(:only_display_on_leaf) and @element.kids.size > 0
      return true
    end

    # fields which does not take user input needs to be check if the data
    # exists.
    if @type == :relation_table
      if @element.cross_link_records[@spec[:id_ref_relation_name]]
        return false
      else
        return true
      end
    end

    v = value
    if v.nil? and (not @flags.include? :req)
      case @type
      when :children
        return @element.kids.size == 0
      else
        return true
      end
    else
      return false
    end
  end

  def default_set v
    if @yaml_value.nil?
      @yaml_value = v
    end
  end

  def value
    if @yaml_value
      return @yaml_value

    elsif @element.parent and @flags.include?(:can_inherit)
      v = @element.parent.get_field_val @yaml_name
      return v if v
    end

    return @spec[:default]
  end

  def name
    if @element.kids.size > 0 and @spec[:name_non_leaf]
      @spec[:name_non_leaf]
    elsif @element.kids.size == 0 and @spec[:name_leaf]
      @spec[:name_leaf]
    else
      @spec[:name]
    end
  end

  def cross_ref_parent
    if @type == :parent
      v = value()
      return if v.nil?
      parent = @page.adoc_id_to_obj v
      if parent
        @element.parent = parent
        parent.kids << @element
      else
        @element.log __LINE__, :error, "Parent ID #{v} not found!"
      end
    end
  end

  def id_to_leaf_objs id
    leaf_ids = []
    objs = []

    id_obj = @page.adoc_id_to_obj id
    if id_obj
      objs << id_obj
    end

    while objs.size > 0
      objs_ = []
      objs.each do |o|
        if o.kids.size == 0
          leaf_ids << o
        else
          o.kids.each do |k|
            objs_ << k
          end
        end
      end
      objs = objs_
    end
    return leaf_ids
  end

  def id_ref_list_to_objs list
    ids = []
    list.each do |v|
      case v
      when /leafs\((\S*)\)/
        ids += id_to_leaf_objs($1)
      else
        ids << @page.adoc_id_to_obj(v)
      end
    end

    ids.uniq
  end

  def cross_ref_id record
    v = value()
    return if v.nil?

    rel = @spec[:id_ref_relation_name]
    return if rel.nil?

    case @type
    when :id_ref
      # todo, check id_ref_type
      id_obj = @page.adoc_id_to_obj v

      if id_obj
        id_obj.cross_link_record rel, record
      end
    when :id_ref_list
      objs = id_ref_list_to_objs(v)
      objs.each do |o|
        log_error "#{$fbasename}:#{__LINE__} One of these refs not found:\n#{v}" if o.nil?
        o.cross_link_record rel, record
      end
    end
  end

  def value_type_to_html value, type
    case type
    when :id
      return @page.adoc_symbol_link_self(value)
    when :parent
      return @page.adoc_symbol_link(value)
    when :id_ref
      return @page.adoc_symbol_link(value)
    when :id_ref_list
      objs = id_ref_list_to_objs(value)
      return objs.collect{|x| @page.adoc_symbol_link(x.id)}.join("<br>")

    when :yang
      return parse_yang_path(@page.html_file_name, value)
    when :bool
      return value
    when :string
      return value
    when :test_results
      return @element.test_result_string()
    when :url
      return "<a href=\"#{value}\">#{value}</a>"
    when :adoc
      return @page.value_adoc_to_html value, @element.id
    when :code
      return "<code style=\"white-space:pre;padding:0px 0px;\">#{value}</code>"
    else
      return nil
    end
  end

  def html
    v = value()

    case @type
    when :children
      return @element.kids.collect{|x| @page.adoc_symbol_link(x.id) }.join(",<br>")
    when :relation_table
      #$log.info "#{$fbasename}:#{__LINE__} Request rel #{@spec[:id_ref_relation_name]} in ID: #{@element.id}"
      data = @element.cross_link_records[@spec[:id_ref_relation_name]]
      html = ""

      return nil if data.nil?

      if @spec[:cols].size == 1
        # Tables with onle one coloumn shall be displayed as list
        list = []
        data.each do |data_record|
          @spec[:cols].each do |k, v|
            val = data_record[k]
            t = v[:type]
            list << value_type_to_html(val, t)
          end
        end
        html += list.join("<br>")

      else
        html += "<table class=\"tableblock frame-all grid-all stretch\" style=\"width:100%;\">"
        html += "<tbody>"

        html += "<tr>"
        @spec[:cols].each do |k, v|
          html += "<th class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">#{v[:name]}</p></th>"
        end
        html += "</tr>"

        data.each do |data_record|
          html += "<tr>"
          #$log.info "#{$fbasename}:#{__LINE__} processing record: #{data_record}"
          @spec[:cols].each do |k, v|
            val = data_record[k]
            t = v[:type]
            h = value_type_to_html val, t
            html += "<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">#{h}</p></td>"
          end
          html += "</tr>"
        end
        html += "</tbody></table>"
        return html
      end

    when :passthrough
      return v

    else
      return value_type_to_html v, @type

    end
  end
end

sitemap = Sitemap.new $opt[:sitemap]
sitemap.populate
sitemap.cross_ref

IO.binwrite($opt[:output], sitemap.html)

if $opt[:ysym]
    puts "YANG symbol table:"
    $yang_symbol_index.each do |k, v|
        puts k
    end
end

if $opt[:write_sym]
    puts "Write yang_symbol_index"
    File.write('yang_symbol_index', "#{PP.pp($yang_symbol_index, "")}")
    puts "Write yang_symbol_group_index"
    File.write('yang_symbol_group_index', "#{PP.pp($yang_symbol_group_index, "")}")
end

exit($log_errors == 0)
